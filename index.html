<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chinese Word Search</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #4a90e2;
            --secondary-color: #f5f5f5;
            --border-color: #ddd;
            --text-color: #333;
            --success-color: #4caf50;
        }
        

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Poppins', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            padding: 20px;
            background-color: #f0f2f5;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .menu {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-width: 600px;
            margin: 0 auto;
        }

        .menu h1 {
            text-align: center;
            margin-bottom: 20px;
            color: var(--primary-color);
            font-weight: 600;
        }

        .options-group {
            margin-bottom: 20px;
        }

        .options-group h2 {
            margin-bottom: 10px;
            font-size: 1.2em;
            font-weight: 500;
        }

        .options-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        button {
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            font-family: 'Poppins', sans-serif;
            font-weight: 500;
        }

        button:hover {
            background: var(--primary-color);
            color: white;
        }

        button.selected {
            background: var(--primary-color);
            color: white;
        }

        .toggle {
            opacity: 0.6;
        }

        .toggle.selected {
            opacity: 1;
            background: var(--primary-color);
            color: white;
        }

        #startGame:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .game-container {
    display: block;
    max-width: calc(100% - 40px);
    margin: 40px auto 0;
    width: fit-content; /* S'adapte au contenu */
}

@media (max-width: 768px) {
    .game-container {
        margin: 20px auto 0;
    }
    
    .game-content {
        grid-template-columns: 1fr;
    }
    
    .game-header {
        padding: 10px 15px;
    }
    
    #backToMenu {
        min-width: auto;
        padding: 6px 10px;
    }
    
    .header-spacer {
        min-width: auto;
    }
}

        .grid-container {
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    width: fit-content;
    margin: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
}

        .word-grid {
            display: grid;
            gap: 5px;
            margin: 0 auto;
        }

        .grid-cell {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            cursor: pointer;
            user-select: none;
            transition: all 0.3s ease;
            background: white;
            border-radius: 4px;
            font-family: 'Noto Sans SC', sans-serif;
            font-weight: 400;
            border: 1px solid var(--border-color);
        }

        .grid-cell:hover {
            background: var(--secondary-color);
        }

        .grid-cell.selected {
            background: var(--primary-color);
            color: white;
        }

        .grid-cell.found {
            background: var(--success-color);
            color: white;
        }

        .word-list {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 300px;
            display: flex;
            flex-direction: column;
            height: 600px;
        }

        .word-list h2 {
            margin-bottom: 15px;
            color: var(--primary-color);
            font-weight: 500;
            font-size: 1.5em;
        }

        .words {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .word-item {
            padding: 12px;
            border-bottom: 1px solid var(--border-color);
            font-size: 1.5em;
            line-height: 1.4;
            font-family: 'Noto Sans SC', sans-serif;
        }

        .word-item .translation, 
        .word-item .pinyin {
            font-size: 0.85em;
            color: #666;
            display: block;
        }

        .word-item.found {
            background-color: #e8f5e9;
        }

        .status-footer {
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
            background: white;
            margin-top: auto;
        }

        .progress-counter {
            text-align: center;
            font-size: 1.2em;
            font-weight: 500;
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .timer {
            text-align: center;
            font-size: 1.2em;
            font-weight: 500;
            color: var(--primary-color);
        }

        .validation-modal, 
        .completion-message {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            z-index: 1000;
            text-align: center;
        }

        .completion-message .stats {
            margin: 15px 0;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 8px;
        }

        .completion-message .time {
            font-size: 1.5em;
            color: var(--primary-color);
            font-weight: 600;
            margin: 10px 0;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }

        .game-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: white;
    padding: 15px 20px;
    border-radius: 10px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    margin-bottom: 20px;
    width: 100%; /* Prend toute la largeur du container */
}


.game-title {
    font-size: 1.5em;
    color: var(--primary-color);
    font-weight: 500;
    margin: 0;
    text-align: center;
    flex: 1; /* Permet au titre de prendre l'espace disponible */
}

#backToMenu {
    padding: 8px 15px;
    border: 1px solid var(--border-color);
    border-radius: 5px;
    background: white;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 1rem;
    color: var(--primary-color);
    min-width: 100px; /* Largeur minimale fixe */
}

.game-content {
    display: grid;
    grid-template-columns: auto 300px;
    gap: 20px;
    width: 100%; /* Prend toute la largeur du container */
}

#backToMenu:hover {
    background: var(--primary-color);
    color: white;
}

.header-spacer {
    min-width: 100px; /* Même largeur que le bouton pour équilibrer */
    visibility: hidden; /* Invisible mais garde l'espace */
}

        .words::-webkit-scrollbar {
            width: 8px;
        }

        .words::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .words::-webkit-scrollbar-thumb {
            background: var(--primary-color);
            border-radius: 4px;
        }

        .words::-webkit-scrollbar-thumb:hover {
            background: #357abd;
        }
#pinyinTooltip {
    position: absolute;
    display: none;
    padding: 4px 8px;
    background: rgba(0,0,0,0.8);
    color: white;
    border-radius: 4px;
    font-size: 0.9em;
    pointer-events: none;
    z-index: 2000;
}
    </style>
</head>
<body>
    <div class="container">
        <!-- Menu Screen -->
        <div class="menu" id="menuScreen">
            <h1>中文 Word Search</h1>
            
            <div class="options-group">
                <h2>HSK Levels</h2>
                <div class="options-buttons" id="hskLevelButtons">
                    <button data-level="1" class="toggle selected">HSK 1</button>
                    <button data-level="2" class="toggle">HSK 2</button>
                    <button data-level="3" class="toggle">HSK 3</button>
                    <button data-level="4" class="toggle">HSK 4</button>
                    <button data-level="5" class="toggle">HSK 5</button>
                    <button data-level="6" class="toggle">HSK 6</button>
                </div>
            </div>
    
            <div class="options-group">
                <h2>Game Mode</h2>
                <div class="options-buttons" id="gameModeButtons">
                    <button data-mode="no_hint" class="selected">No Hints</button>
                    <button data-mode="characters">Characters</button>
                    <button data-mode="translation">Translations</button>
                    <button data-mode="pinyin">Pinyin</button>
                </div>
            </div>
    
            <div class="options-group">
                <h2>Grid Size</h2>
                <div class="options-buttons" id="gridSizeButtons">
                    <button data-size="5" class="selected">5x5</button>
                    <button data-size="7">7x7</button>
                    <button data-size="9">9x9</button>
                    <button data-size="11">11x11</button>
                    <button data-size="13">13x13</button>
                </div>
            </div>

            <div style="margin: 20px 0; text-align:center;">
                <label>
                 <input type="checkbox" id="showPinyinCheckbox">
                    Show pinyin
                </label>
            </div>
    
            <button id="startGame" style="width: 100%; margin-top: 20px;">Start Game</button>
        </div>

        <!-- Game Screen -->
        <div class="game-container" id="gameScreen">
            <button id="backToMenu">← Back to Menu</button>
            
            <div style="display: grid; grid-template-columns: auto 300px; gap: 20px; margin-top: 40px;">
                <div class="grid-container">
                    <div class="word-grid" id="wordGrid"></div>
                </div>
                
                <div class="word-list">
                    <h2>Words to Find</h2>
                    <div class="words" id="wordsList"></div>
                    <div class="status-footer">
                        <div class="progress-counter" id="progressCounter">Found: 0/0</div>
                        <div class="timer" id="gameTimer">00:00</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Modals -->
        <div class="validation-modal" id="validationModal">
            <h3>Confirm Selection</h3>
            <p>Selected word: <span id="selectedWord"></span></p>
            <div class="modal-buttons">
                <button id="confirmSelection">Confirm</button>
                <button id="cancelSelection">Cancel</button>
            </div>
        </div>

        <div class="completion-message" id="completionMessage">
            <h3>Congratulations!</h3>
            <p>You found all the words!</p>
            <div class="stats">
                <p>Time taken: <span id="finalTime" class="time">00:00</span></p>
                <p>Words found: <span id="finalWordCount">0</span></p>
            </div>
            <button id="newGameButton" style="margin-top: 15px;">Start New Game</button>
        </div>

        <div class="overlay" id="overlay"></div>
    </div>

    <script>
    
    const GRID_CONFIGS = {
    '5': { size: 5, wordCount: 4 },      // Petite grille, 4 mots est idéal
    '7': { size: 7, wordCount: 6 },      // 6 mots pour une grille moyenne
    '9': { size: 9, wordCount: 9 },      // 9 mots pour une grille 9x9
    '11': { size: 11, wordCount: 12 },   // 12 mots pour 11x11
    '13': { size: 13, wordCount: 16 }    // 16 mots pour la plus grande grille
};

    const DIRECTIONS = [
        { dx: 1, dy: 0, name: 'horizontal' },
        { dx: -1, dy: 0, name: 'horizontal-rev' },
        { dx: 0, dy: 1, name: 'vertical' },
        { dx: 0, dy: -1, name: 'vertical-rev' }
    ];

    // Game state
    const gameState = {
    mode: 'no_hint',
    gridSize: 5,
    selectedHskLevels: new Set([1]),
    selectedCells: [],
    wordsToFind: [],
    foundWords: new Set(),
    currentGrid: [],
    wordPlacements: [],
    startTime: null,
    timerInterval: null
    showPinyin: false 
};

function getWordsForCurrentLevel() {
    let combinedWords = [];
    for (const level of gameState.selectedHskLevels) {
        switch(level) {
            case 1:
                combinedWords = combinedWords.concat(hsk1Words || []);
                break;
            case 2:
                combinedWords = combinedWords.concat(hsk2Words || []);
                break;
            case 3:
                combinedWords = combinedWords.concat(hsk3Words || []);
                break;
            case 4:
                combinedWords = combinedWords.concat(hsk4Words || []);
                break;
            case 5:
                combinedWords = combinedWords.concat(hsk5Words || []);
                break;
            case 6:
                combinedWords = combinedWords.concat(hsk6Words || []);
                break;
        }
    }
    return combinedWords;
}

    // Initialize game when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
        initializeGame();
    });

    function initializeGame() {
    // Reset initial game state
    gameState.mode = 'no_hint';
    gameState.gridSize = 5;
    gameState.selectedHskLevels = new Set([1]); // Default to HSK1
    gameState.selectedCells = [];
    gameState.wordsToFind = [];
    gameState.foundWords = new Set();
    gameState.currentGrid = [];
    gameState.wordPlacements = [];
    gameState.startTime = null;
    gameState.timerInterval = null;

    const showPinyinCheckbox = document.getElementById('showPinyinCheckbox');
        gameState.showPinyin = showPinyinCheckbox.checked;

        showPinyinCheckbox.addEventListener('change', () => {
        gameState.showPinyin = showPinyinCheckbox.checked;
    });

    // Update game screen structure with header-spacer class
    const gameScreen = document.getElementById('gameScreen');
    if (gameScreen) {
        gameScreen.innerHTML = `
            <div class="game-header">
                <button id="backToMenu">← Back</button>
                <h2 class="game-title">中文 Word Search</h2>
                <div class="header-spacer"></div>
            </div>
            <div class="game-content">
                <div class="grid-container">
                    <div class="word-grid" id="wordGrid"></div>
                </div>
                <div class="word-list">
                    <h2>Words to Find</h2>
                    <div class="words" id="wordsList"></div>
                    <div class="status-footer">
                        <div class="progress-counter" id="progressCounter">Found: 0/0</div>
                        <div class="timer" id="gameTimer">00:00</div>
                    </div>
                </div>
            </div>
        `;
    }

    // Le reste de la fonction initializeGame reste identique
    
    // Initialize HSK level buttons with multiple selection
    document.querySelectorAll('#hskLevelButtons button').forEach(button => {
        button.addEventListener('click', () => {
            const level = parseInt(button.dataset.level);
            button.classList.toggle('selected');
            
            if (button.classList.contains('selected')) {
                gameState.selectedHskLevels.add(level);
            } else {
                gameState.selectedHskLevels.delete(level);
            }

            const startButton = document.getElementById('startGame');
            startButton.disabled = gameState.selectedHskLevels.size === 0;
        });
    });

    // Initialize game mode buttons
    document.querySelectorAll('#gameModeButtons button').forEach(button => {
        button.addEventListener('click', () => {
            document.querySelectorAll('#gameModeButtons button')
                .forEach(b => b.classList.remove('selected'));
            button.classList.add('selected');
            gameState.mode = button.dataset.mode;
        });
    });

    // Initialize grid size buttons
    document.querySelectorAll('#gridSizeButtons button').forEach(button => {
        button.addEventListener('click', () => {
            document.querySelectorAll('#gridSizeButtons button')
                .forEach(b => b.classList.remove('selected'));
            button.classList.add('selected');
            gameState.gridSize = parseInt(button.dataset.size);
        });
    });

    // Initialize main control buttons
    const startGameButton = document.getElementById('startGame');
    startGameButton.addEventListener('click', () => {
        if (gameState.selectedHskLevels.size === 0) {
            alert("Please select at least one HSK level");
            return;
        }
        
        const grid = generateGrid();
        if (grid) {
            gameState.currentGrid = grid;
            startGame();
        }
    });

    // Initialize back to menu button
    const backToMenuButton = document.getElementById('backToMenu');
    if (backToMenuButton) {
        backToMenuButton.addEventListener('click', () => {
            stopTimer();
            showMenu();
        });
    }

    // Initialize word selection confirmation buttons
    const confirmSelectionButton = document.getElementById('confirmSelection');
    if (confirmSelectionButton) {
        confirmSelectionButton.addEventListener('click', confirmSelection);
    }

    const cancelSelectionButton = document.getElementById('cancelSelection');
    if (cancelSelectionButton) {
        cancelSelectionButton.addEventListener('click', cancelSelection);
    }

    // Initialize new game button
    const newGameButton = document.getElementById('newGameButton');
    if (newGameButton) {
        newGameButton.addEventListener('click', () => {
            hideCompletionMessage();
            showMenu();
        });
    }

    // Initialize grid cell click handler
    const wordGrid = document.getElementById('wordGrid');
    if (wordGrid) {
        wordGrid.addEventListener('click', (event) => {
            const cell = event.target;
            if (cell.classList.contains('grid-cell')) {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                handleCellClick(row, col);
            }
        });
    }

    // Initialize overlay handlers
    const overlay = document.getElementById('overlay');
    if (overlay) {
        overlay.addEventListener('click', (event) => {
            if (event.target.id === 'overlay') {
                hideValidationModal();
                hideCompletionMessage();
                clearSelection();
            }
        });
    }

    // Initialize keyboard shortcuts
    document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
            hideValidationModal();
            hideCompletionMessage();
            clearSelection();
        } else if (event.key === 'Enter' && 
                   document.getElementById('validationModal').style.display === 'block') {
            confirmSelection();
        }
    });

    // Add window resize handler
    window.addEventListener('resize', () => {
        if (gameState.currentGrid.length > 0) {
            renderGrid();
        }
    });

    // Verify word lists availability
    const availableWordLists = [hsk1Words].filter(list => list && list.length > 0);
    
    if (availableWordLists.length === 0) {
        startGameButton.disabled = true;
        console.error('No word lists properly loaded');
        alert('Error: Word lists not properly loaded. Please refresh the page.');
    }

    // Ensure default HSK1 is selected
    document.querySelector('#hskLevelButtons button[data-level="1"]').classList.add('selected');

    // Show initial menu
    showMenu();
}

function startGame() {
    // Cacher le menu et montrer l'écran de jeu
    document.getElementById('menuScreen').style.display = 'none';
    document.getElementById('gameScreen').style.display = 'block';
    
    // Réinitialiser l'état du jeu
    gameState.foundWords.clear();
    gameState.selectedCells = [];
    
    // Rendre la grille
    renderGrid();
    
    // Rendre la liste des mots
    renderWordsList();
    
    // Démarrer le timer
    startTimer();
    
    // Mettre à jour le compteur de progression
    updateProgressCounter();
}


    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    function logGrid(grid) {
    console.log("État actuel de la grille:");
    let display = '';
    for (let y = 0; y < grid.length; y++) {
        for (let x = 0; x < grid[y].length; x++) {
            display += (grid[y][x] || '_') + ' ';
        }
        display += '\n';
    }
    console.log(display);
}

function addNewStyles() {
    const styleSheet = document.createElement("style");
    styleSheet.textContent = newStyles;
    document.head.appendChild(styleSheet);
}

function updateGameScreenStructure() {
    const gameScreen = document.getElementById('gameScreen');
    if (!gameScreen) return;

    // Sauvegarder le contenu existant
    const existingContent = gameScreen.innerHTML;

    // Créer la nouvelle structure
    gameScreen.innerHTML = `
        <div class="game-header">
            <button id="backToMenu">← Back to Menu</button>
            <h2 class="game-title">中文 Word Search</h2>
            <div style="width: 100px;"></div> <!-- Spacer pour centrer le titre -->
        </div>
        <div class="game-content">
            <div class="grid-container">
                <div class="word-grid" id="wordGrid"></div>
            </div>
            <div class="word-list">
                <h2>Words to Find</h2>
                <div class="words" id="wordsList"></div>
                <div class="status-footer">
                    <div class="progress-counter" id="progressCounter">Found: 0/0</div>
                    <div class="timer" id="gameTimer">00:00</div>
                </div>
            </div>
        </div>
    `;

    // Réattacher les gestionnaires d'événements
    const backToMenuButton = document.getElementById('backToMenu');
    backToMenuButton.addEventListener('click', showMenu);
}

function showMenu() {
    document.getElementById('gameScreen').style.display = 'none';
    document.getElementById('menuScreen').style.display = 'block';
    resetGame();
}
    function generateGrid() {
    const grid = Array(gameState.gridSize).fill().map(() => 
        Array(gameState.gridSize).fill(''));

    const config = GRID_CONFIGS[gameState.gridSize.toString()];
    const numWords = config.wordCount;  // Nombre fixe de mots selon la taille de la grille

    // Obtenir les mots disponibles pour les niveaux HSK sélectionnés
    const availableWords = [];
    for (const level of gameState.selectedHskLevels) {
        switch(level) {
            case 1: availableWords.push(...hsk1Words); break;
            case 2: availableWords.push(...hsk2Words); break;
            case 3: availableWords.push(...hsk3Words); break;
            case 4: availableWords.push(...hsk4Words); break;
            case 5: availableWords.push(...hsk5Words); break;
            case 6: availableWords.push(...hsk6Words); break;
        }
    }

    // Filtrer les mots selon la taille de la grille
    const eligibleWords = availableWords.filter(word => {
        const wordLength = word.chinese.length;
        return wordLength >= 2 && wordLength <= gameState.gridSize;
    });

    if (eligibleWords.length < numWords) {
        alert(`Not enough valid words available for this grid size. Need ${numWords} words but only found ${eligibleWords.length}.`);
        return null;
    }

    // Sélectionner les mots
    gameState.wordsToFind = [];
    gameState.wordPlacements = [];
    const selectedWords = shuffleArray([...eligibleWords]).slice(0, numWords);

    // Placer les mots
    for (const word of selectedWords) {
        let placed = false;
        let attempts = 0;
        const maxAttempts = 50;

        while (!placed && attempts < maxAttempts) {
            const x = Math.floor(Math.random() * gameState.gridSize);
            const y = Math.floor(Math.random() * gameState.gridSize);
            const direction = DIRECTIONS[Math.floor(Math.random() * DIRECTIONS.length)];

            if (canPlaceWord(word.chinese, x, y, direction, grid)) {
                placeWord(word.chinese, x, y, direction, grid);
                gameState.wordsToFind.push(word);
                placed = true;
            }
            attempts++;
        }

        if (!placed) {
            console.log("Failed to place word, retrying grid generation");
            return generateGrid();
        }
    }

    // Remplir les cases vides
    const uniqueChars = new Set();
    availableWords.forEach(word => {
    for (const char of word.chinese) {
        uniqueChars.add(char);
    }
		});
	const availableChars = Array.from(uniqueChars);
	
	if (availableChars.length === 0) {
    availableChars.push('一','人','大','中','国');
	}

    for (let y = 0; y < gameState.gridSize; y++) {
        for (let x = 0; x < gameState.gridSize; x++) {
            if (grid[y][x] === '') {
                const randomChar = availableChars[Math.floor(Math.random() * availableChars.length)];
                grid[y][x] = randomChar;
            }
        }
    }

    return grid;
}

function wouldCreateUnintendedWord(word, startX, startY, direction, grid, allowedWords) {
    const { dx, dy } = direction;
    const tempGrid = grid.map(row => [...row]);
    
    // Temporarily place the word
    for (let i = 0; i < word.length; i++) {
        tempGrid[startY + (dy * i)][startX + (dx * i)] = word[i];
    }
    
    // Check for unintended words in all directions
    const directions = [
        {dx: 1, dy: 0},  // horizontal
        {dx: 0, dy: 1},  // vertical
    ];
    
    for (let y = 0; y < gameState.gridSize; y++) {
        for (let x = 0; x < gameState.gridSize; x++) {
            for (const dir of directions) {
                let currentWord = '';
                let curX = x;
                let curY = y;
                
                while (curX >= 0 && curX < gameState.gridSize && 
                       curY >= 0 && curY < gameState.gridSize && 
                       tempGrid[curY][curX] !== '') {
                    currentWord += tempGrid[curY][curX];
                    if (currentWord.length >= 2) {
                        // Check if this combination exists in any HSK level word list
                        // but is not in the allowed words list
                        const isUnintendedWord = !allowedWords.some(w => 
                            w.chinese === currentWord);
                        if (isUnintendedWord) return true;
                    }
                    curX += dir.dx;
                    curY += dir.dy;
                }
            }
        }
    }
    
    return false;
}

function canPlaceWord(word, startX, startY, direction, grid) {
    const { dx, dy } = direction;
    
    for (let i = 0; i < word.length; i++) {
        const x = startX + (dx * i);
        const y = startY + (dy * i);
        
        if (x < 0 || x >= gameState.gridSize || y < 0 || y >= gameState.gridSize) {
            return false;
        }
        
        if (grid[y][x] !== '' && grid[y][x] !== word[i]) {
            return false;
        }
    }
    return true;
}

    function placeWord(word, startX, startY, direction, grid) {
        const { dx, dy } = direction;
        
        for (let i = 0; i < word.length; i++) {
            const x = startX + (dx * i);
            const y = startY + (dy * i);
            grid[y][x] = word[i];
        }

        gameState.wordPlacements.push({
            word: word,
            start: { x: startX, y: startY },
            direction: direction.name
        });
    }

    function extractUniqueCharacters() {
    const uniqueChars = new Set();
    getWordsForCurrentLevel().forEach(word => {
        [...word.chinese].forEach(char => uniqueChars.add(char));
    });
    return Array.from(uniqueChars);
}

function resetGame() {
    gameState.foundWords.clear();
    gameState.selectedCells = [];
    gameState.wordPlacements = [];
    gameState.currentGrid = [];
    gameState.wordsToFind = [];
    stopTimer();
    updateProgressCounter();
}

function renderGrid() {
    const wordGrid = document.getElementById('wordGrid');
    const cellSize = 60;
    wordGrid.style.gridTemplateColumns = `repeat(${gameState.gridSize}, ${cellSize}px)`;
    const totalSize = (gameState.gridSize * cellSize) + ((gameState.gridSize - 1) * 5);
    wordGrid.style.width = `${totalSize}px`;
    wordGrid.style.height = `${totalSize}px`;

    wordGrid.innerHTML = '';

    gameState.currentGrid.forEach((row, i) => {
        row.forEach((cell, j) => {
            const cellElement = document.createElement('div');
            cellElement.className = 'grid-cell';
            cellElement.textContent = cell;
            cellElement.dataset.row = i;
            cellElement.dataset.col = j;
            wordGrid.appendChild(cellElement);

            // Survol (PC)
            cellElement.addEventListener('mouseenter', (e) => {
                if (!gameState.showPinyin) return;
                const char = e.target.textContent;
                if (pinyinDict[char]) {
                    const tooltip = document.getElementById('pinyinTooltip');
                    tooltip.textContent = pinyinDict[char];
                    tooltip.style.left = (e.pageX + 10) + 'px';
                    tooltip.style.top = (e.pageY + 10) + 'px';
                    tooltip.style.display = 'block';
                }
            });

            cellElement.addEventListener('mousemove', (e) => {
                if (!gameState.showPinyin) return;
                const tooltip = document.getElementById('pinyinTooltip');
                tooltip.style.left = (e.pageX + 10) + 'px';
                tooltip.style.top = (e.pageY + 10) + 'px';
            });

            cellElement.addEventListener('mouseleave', () => {
                document.getElementById('pinyinTooltip').style.display = 'none';
            });

            // Mobile (tap court)
            cellElement.addEventListener('touchstart', (e) => {
                if (!gameState.showPinyin) return;
                const char = e.target.textContent;
                if (pinyinDict[char]) {
                    const tooltip = document.getElementById('pinyinTooltip');
                    tooltip.textContent = pinyinDict[char];
                    tooltip.style.left = (e.touches[0].pageX + 10) + 'px';
                    tooltip.style.top = (e.touches[0].pageY + 10) + 'px';
                    tooltip.style.display = 'block';
                }
            });

            cellElement.addEventListener('touchend', () => {
                setTimeout(() => {
                    document.getElementById('pinyinTooltip').style.display = 'none';
                }, 800);
            });
        });
    });

    updateFoundCells();
}


function renderWordsList() {
    const wordsList = document.getElementById('wordsList');
    wordsList.innerHTML = '';
    
    gameState.wordsToFind.forEach(word => {
        const li = document.createElement('li');
        li.dataset.word = word.chinese;
        li.className = 'word-item';
        
        if (gameState.foundWords.has(word.chinese)) {
            // Toujours afficher les informations complètes pour les mots trouvés
            li.className += ' found';
            li.innerHTML = `
                <div class="chinese-line">${word.chinese}</div>
                <span class="pinyin">${word.pinyin}</span>
                <span class="translation">${word.translation}</span>
            `;
        } else if (gameState.mode !== 'no_hint') {
            // Pour les mots non trouvés, afficher selon le mode
            switch(gameState.mode) {
                case 'characters':
                    li.innerHTML = `<div class="chinese-line">${word.chinese}</div>`;
                    break;
                case 'translation':
                    li.innerHTML = `<span class="translation">${word.translation}</span>`;
                    break;
                case 'pinyin':
                    li.innerHTML = `<span class="pinyin">${word.pinyin}</span>`;
                    break;
            }
        } else {
            // Ne pas afficher les mots non trouvés en mode no_hint
            return;
        }
        
        wordsList.appendChild(li);
    });
    
    updateProgressCounter();
}

    function handleCellClick(row, col) {
    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    
    if (gameState.selectedCells.length === 0) {
        // Premier clic
        gameState.selectedCells.push({row, col});
        cell.classList.add('selected');
    } else {
        // Deuxième clic
        const start = gameState.selectedCells[0];
        const end = {row, col};

        // Vérifier si c'est un clic sur la même cellule
        if (start.row === end.row && start.col === end.col) {
            clearSelection();
            return;
        }

        // Calcul de la direction
        const dx = Math.sign(end.col - start.col);
        const dy = Math.sign(end.row - start.row);

        // Vérifie si la sélection est valide (horizontale ou verticale uniquement)
        if (dx !== 0 && dy !== 0) {
            clearSelection();
            return;
        }

        // Sélectionne toutes les cellules entre le début et la fin
        const cellsBetween = getCellsBetween(start, end);
        cellsBetween.forEach(pos => {
            const cell = document.querySelector(
                `[data-row="${pos.row}"][data-col="${pos.col}"]`
            );
            cell.classList.add('selected');
        });

        gameState.selectedCells = cellsBetween;
        document.getElementById('selectedWord').textContent = getSelectedWord();
        showValidationModal();
    }
}

function getCellsBetween(start, end) {
    const cells = [];
    const dx = Math.sign(end.col - start.col);
    const dy = Math.sign(end.row - start.row);
    
    // Calcul du nombre de cellules à inclure
    const length = Math.max(
        Math.abs(end.col - start.col),
        Math.abs(end.row - start.row)
    ) + 1;

    // Ajouter chaque cellule dans le chemin
    for (let i = 0; i < length; i++) {
        cells.push({
            row: start.row + (dy * i),
            col: start.col + (dx * i)
        });
    }

    return cells;
}

    function getSelectedWord() {
        return gameState.selectedCells.map(pos => 
            gameState.currentGrid[pos.row][pos.col]
        ).join('');
    }

    function validateSelection() {
    const selectedWord = getSelectedWord();
    if (selectedWord.length < 2) return false;
    
    const reverseSelectedWord = selectedWord.split('').reverse().join('');
    
    // Vérifier si le mot (ou son inverse) est déjà trouvé pour éviter les doublons
    if ([selectedWord, reverseSelectedWord].some(word => gameState.foundWords.has(word))) {
        return false;
    }
    
    // Chercher le mot dans les placements
    const foundPlacement = gameState.wordPlacements.find(placement => 
        placement.word === selectedWord || placement.word === reverseSelectedWord
    );

    if (foundPlacement && gameState.foundWords.size < gameState.wordsToFind.length) {
        const foundWord = gameState.wordsToFind.find(word => 
            word.chinese === foundPlacement.word
        );
        
        if (foundWord) {
            gameState.foundWords.add(foundWord.chinese);
            
            // Vérifier si on a vraiment trouvé tous les mots
            if (gameState.foundWords.size === gameState.wordsToFind.length) {
                setTimeout(showCompletionMessage, 500);
            }
            return true;
        }
    }
    return false;
}

function updateFoundCells() {
    document.querySelectorAll('.grid-cell.found').forEach(cell => {
        cell.classList.remove('found');
    });

    gameState.wordPlacements.forEach(placement => {
        if (gameState.foundWords.has(placement.word)) {
            markPlacementCells(placement, 'found');
        }
    });

    document.getElementById('progressCounter').textContent = 
        `Found: ${gameState.foundWords.size}/${gameState.wordsToFind.length}`;
}

function markPlacementCells(placement, className) {
    const dir = DIRECTIONS.find(d => d.name === placement.direction);
    for (let i = 0; i < placement.word.length; i++) {
        const row = placement.start.y + dir.dy * i;
        const col = placement.start.x + dir.dx * i;
        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        if (cell) cell.classList.add(className);
    }
}

function updateProgressCounter() {
    const actualFoundCount = Math.min(gameState.foundWords.size, gameState.wordsToFind.length);
    document.getElementById('progressCounter').textContent = 
        `Found: ${actualFoundCount}/${gameState.wordsToFind.length}`;
}

    function showValidationModal() {
        document.getElementById('validationModal').style.display = 'block';
        document.getElementById('overlay').style.display = 'block';
    }

    function hideValidationModal() {
        document.getElementById('validationModal').style.display = 'none';
        document.getElementById('overlay').style.display = 'none';
    }

    function showCompletionMessage() {
    stopTimer();
    const finalTime = document.getElementById('gameTimer').textContent;
    document.getElementById('finalTime').textContent = finalTime;
    const actualWordCount = Math.min(gameState.foundWords.size, gameState.wordsToFind.length);
    document.getElementById('finalWordCount').textContent = 
        `${actualWordCount}/${gameState.wordsToFind.length}`;
    
    const completionMessage = document.getElementById('completionMessage');
    
    // Modifier le style des boutons
    if (!document.getElementById('closeCompletionMessage')) {
        const closeButton = document.createElement('button');
        closeButton.id = 'closeCompletionMessage';
        closeButton.textContent = 'Close';
        closeButton.style.width = '100%';  // Même largeur que Start Game
        closeButton.style.marginTop = '10px';
        closeButton.style.padding = '10px 15px';  // Même padding que les autres boutons
        closeButton.style.fontSize = '1rem';  // Même taille de police
        
        // Conteneur pour les boutons
        const buttonContainer = document.createElement('div');
        buttonContainer.style.display = 'flex';
        buttonContainer.style.flexDirection = 'column';  // Empiler les boutons verticalement
        buttonContainer.style.gap = '10px';
        buttonContainer.style.marginTop = '15px';
        
        const newGameButton = document.getElementById('newGameButton');
        if (newGameButton) {
            newGameButton.remove();
            newGameButton.style.width = '100%';  // Même largeur
            buttonContainer.appendChild(newGameButton);
        }
        buttonContainer.appendChild(closeButton);
        
        completionMessage.appendChild(buttonContainer);
        
        closeButton.addEventListener('click', () => {
            hideCompletionMessage();
        });
    }
    
    completionMessage.style.display = 'block';
    document.getElementById('overlay').style.display = 'block';
}

    function hideCompletionMessage() {
        document.getElementById('completionMessage').style.display = 'none';
        document.getElementById('overlay').style.display = 'none';
    }

    function confirmSelection() {
    if (validateSelection()) {
        const selectedWord = getSelectedWord();
        markFoundWord();
        updateProgressCounter();
    }
    hideValidationModal();
    clearSelection();
}
    function cancelSelection() {
        hideValidationModal();
        clearSelection();
    }

    function clearSelection() {
        document.querySelectorAll('.grid-cell.selected').forEach(cell => {
            cell.classList.remove('selected');
        });
        gameState.selectedCells = [];
    }

    function markFoundWord() {
    gameState.selectedCells.forEach(pos => {
        const cell = document.querySelector(
            `[data-row="${pos.row}"][data-col="${pos.col}"]`
        );
        cell.classList.add('found');
    });
    
    // Force le rafraîchissement de la liste des mots
    renderWordsList();
}

    function startTimer() {
        gameState.startTime = new Date();
        updateTimer(); // Mise à jour immédiate
        gameState.timerInterval = setInterval(updateTimer, 1000);
    }

    function stopTimer() {
        if (gameState.timerInterval) {
            clearInterval(gameState.timerInterval);
            gameState.timerInterval = null;
        }
    }

    function updateTimer() {
        if (!gameState.startTime) return;
        
        const now = new Date();
        const diff = Math.floor((now - gameState.startTime) / 1000);
        const minutes = Math.floor(diff / 60);
        const seconds = diff % 60;
        
        const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        document.getElementById('gameTimer').textContent = timeString;
    }

    function updateWordsList() {
    if (gameState.mode === 'no_hint') {
        // En mode "no hint", on recrée complètement la liste
        renderWordsList();
    } else {
        // Pour les autres modes, on met à jour uniquement les statuts
        const wordItems = document.getElementById('wordsList').querySelectorAll('.word-item');
        wordItems.forEach(item => {
            if (item.dataset.word && gameState.foundWords.has(item.dataset.word)) {
                item.classList.add('found');
            }
        });
    }
}
</script>
<script src="js/pinyinDict.js"></script>
<script src="js/dico_words.js"></script>
<script src="js/ton_script_principal.js"></script>
<div id="pinyinTooltip"></div>
</body>
</html>
